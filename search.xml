<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[关于RunLoop的笔记]]></title>
      <url>%2F2018%2F04%2F01%2F%E5%85%B3%E4%BA%8ERunLoop%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[关于 RunLoop 笔记📒RunLoopRunLoop实际上是个对象，在循环中用来处理程序运行过程中出现的各种事情（比如触摸、UI刷新、timer、selector），从而保持程序持续运行；而且在没有事件处理的状态下，会进入睡眠模式，节省CPU消耗，提高程序性能。 iOS开发中提供NSRunLoop &amp; CFRunloopRef； CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 RunLoop 与线程的关系RunLoop是基于线程pthread管理，pthread和RunLoop之间是一一对应，其关系是保存在一个全局的字典里。刚创建线程是不会有RunLoop，只有第一次获取RunLoop的时候会创建RunLoop，同时在线程结束的时候会销毁对应的RunLoop。 CFRunLoopRefRunLoop Mode CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 他们之间的关系如图： 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响. 系统默认提供： kCFRunLoopDefaultMode(NSDefaultRunLoopMode) 系统默认的mode，不做任何操作就在该mode中。 UITrackingRunLoopMode 滑动UIScrollView的时候，切换成该mode。 至于 kCFRunLoopCommonModes（NSRunLoopCommonModes），并不是具体某个mode，而是个mode组合模式，默认包含前两者mode。自定义的mode可以通过CFRunLoopAddCommonMode()添加到kCFRunLoopCommonModes中。 SourceCFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 ObserverCFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 123456789/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 进入RunLoop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将开始Timer处理 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将开始Source处理 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //从休眠状态唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //退出RunLoop&#125;; RunLoop 的内部逻辑实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop的应用NSTimerNSTimer的创建通常有两种方法，都是类方法： timeWithXXX scheduedTimerWithXXX二者最大的区别是后者创建timer会自动以NSDefaultRunLoopMode mode添加到当前线程RunLoop中，不添加到RunLoop中是无法正常工作的。NSTimer &amp; 内存管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445import "ViewController1.h"@interface ViewController1 ()@property (nonatomic,weak) NSTimer *timer1;@property (nonatomic,weak) NSTimer *timer2;@end@implementation ViewController1- (void)viewDidLoad &#123;[super viewDidLoad];// timer1创建后会自动以NSDefaultRunLoopMode默认模式添加到当前RunLoop中，所以可以正常工作self.timer1 = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timeInterval:) userInfo:nil repeats:YES];NSTimer *tempTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timeInterval:) userInfo:nil repeats:YES];// 如果不把timer2添加到RunLoop中是无法正常工作的(注意如果想要在滚动UIScrollView时timer2可以正常工作可以将NSDefaultRunLoopMode改为NSRunLoopCommonModes)[[NSRunLoop currentRunLoop] addTimer:tempTimer forMode:NSDefaultRunLoopMode];self.timer2 = tempTimer; CGRect rect = [UIScreen mainScreen].bounds;UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectInset(rect, 0, 200)];[self.view addSubview:scrollView];UIView *contentView = [[UIView alloc] initWithFrame:CGRectInset(scrollView.bounds, -100, -100)];contentView.backgroundColor = [UIColor redColor];[scrollView addSubview:contentView];scrollView.contentSize = contentView.frame.size;&#125;- (void)timeInterval:(NSTimer *)timer &#123; if (self.timer1 == timer) &#123;NSLog(@"timer1..."); &#125; else &#123;NSLog(@"timer2..."); &#125;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; [self dismissViewControllerAnimated:true completion:nil];&#125;- (void)dealloc &#123;NSLog(@"ViewController1 dealloc...");&#125;@end 上述代码中存在两个问题：ViewController 和 timer 均无法释放。ViewController无法释放的原因是：创建timer的时候NStimer的target指定self（即ViewController），这样timer对ViewController有了一个强引用。解决的方法有两种，基本思路是一样的，就是对target进行转移： 将target分离出来独立成一个对象（在这个对象中创建NSTimer并将对象本身作为NSTimer的target），ViewController通过这个对象间接使用NSTimer； 直接增加NSTimer扩展（category），让NSTimer自身做为target，同时可以将操作selector封装到block中。后者相对优雅，也是目前使用较多的方案（目前有大量类似的封装，例如：NSTimer+Block）。显然Apple也认识到了这个问题，如果你可以确保代码只在iOS 10下运行就可以使用iOS 10新增的系统级block方案）。至于timer无法释放的原因是：为了确保定时器正常运转，当加入到RunLoop以后系统会对NSTimer执行一次retain操作。解决的方法是：在dealloc方法中调用NSTimer的invalidate方法就行。UI更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\_ZN2CA11Transaction17observer\_callbackEP19\_\_CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 阅读文章：iOS刨根问底-深入理解RunLoop深入理解RunLoop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《编程的智慧》的笔记]]></title>
      <url>%2F2017%2F05%2F23%2F%E8%AF%BB%E3%80%8A%E7%BC%96%E7%A8%8B%E7%9A%84%E6%99%BA%E6%85%A7%E3%80%8B%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[反复推敲代码提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。 写优雅的代码 优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。 写模块化的代码一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。想要达到很好的模块化，你需要做到以下几点： 避免写太长的函数； 制造小的工具函数； 每个函数只做一件简单的事情；举个🌰：比如某些人喜欢写“通用”函数： void foo() { if (getOS().equals(&quot;MacOS&quot;)) { a(); } else { b(); } c(); if (getOS().equals(&quot;MacOS&quot;)) { d(); } else { e(); } } 这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数： void fooMacOS() { a(); c(); d(); } 和 void fooOther() { b(); c(); e(); } 如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样： void foo() { a(); b() c(); if (getOS().equals(&quot;MacOS&quot;)) { d(); } else { e(); } } 其中a()，b()，c()都是一样的，只有d()和e()根据系统有所不同。那么你可以把a()，b()，c()提取出去： void preFoo() { a(); b() c(); 然后制造两个函数： void fooMacOS() { preFoo(); d(); } 和 void fooOther() { preFoo(); e(); } 避免使用全局变量和类成员来传递信息，尽量是用局部变量和参数； 写可读的代码注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。实际上，真正优雅可读的代码，是几乎不需要注释的。如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要： 使用有意义的函数和变量名字； 局部变量应该尽量接近使用它的地方； 局部变量名字应该简短； 不要重用局部变量； 把复杂的逻辑提取出去，做成“帮助函数”； 把复杂的表达式提取出去，做成中间变量； 在合理的地方换行；举个🌰： if (someLongCondition1() &amp;&amp; someLongCondition2() &amp;&amp; someLongCondition3() &amp;&amp; someLongCondition4()) { ... } 这样形式的表达，更方便别人理解代码的逻辑： if (someLongCondition1() &amp;&amp; someLongCondition2() &amp;&amp; someLongCondition3() &amp;&amp; someLongCondition4()) { ... } 再举个🌰： log.info(&quot;failed to find file {} for command {}, with exception {}&quot;, file, command, exception); file，command和exception本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子： log.info(&quot;failed to find file {} for command {}, with exception {}&quot;, file, command, exception); 写简单的代码现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。 避免使用自增减表达式（i++，++i，i–，–i）； 永远不要省略花括号； 合理使用括号，不要盲目依赖操作符优先级； 避免使用continue和break： 如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。 如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。 有时候你可以把break替换成return，从而去掉break。 如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。 写直观的代码我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。 if (action1() || action2() &amp;&amp; action3()) { ... } ＝》 if (!action1()) { if (action2()) { action3(); } } 写无懈可击的代码if (...) { if (...) { ... return false; } else { return true; } } else if (...) { ... return false; } else { return true; } 使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。 正确处理错误try { ... } catch里面，应该包含尽量少的代码。比如，如果foo和bar都可能产生异常A，你的代码应该尽可能写成： try { foo(); } catch (A e) {...} try { bar(); } catch (A e) {...} ＝》 try { foo(); bar(); } catch (A e) {...} 正确处理null指针这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则： 尽量不要产生null指针； 不要catch NullPointerException； 不要把null放进“容器数据结构”里面； 函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播； 函数作者：明确声明不接受null参数，当参数是null时立即崩溃； 使用@NotNull和@Nullable标记； 使用Optional类型 防止过度工程我总结出来的防止过度工程的原则如下： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题； 先写出可用的代码，反复推敲，再考虑是否需要重用的问题； 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSDate]]></title>
      <url>%2F2017%2F05%2F14%2FNSDate%2F</url>
      <content type="text"><![CDATA[NSDateNSDate 初始化获取的时间与事实相差8小时NSDate *date = [NSDate date]; NSLog(@&quot;Date : %@&quot;, date); //2017-05-14 16:59:03 NSDateDemoDate : 2017-05-14 08:59:03 +0000 原因是他获取的是零时区的时间，而我大天朝在东八区，所以有八个小时的时差！Solution: NSTimeZone *zone = [NSTimeZone systemTimeZone]; NSTimeInterval timeInterval = [zone secondsFromGMTForDate:date]; NSDate *localDate = [date dateByAddingTimeInterval:timeInterval]; NSLog(@&quot;Local Date: %@&quot;,localDate); //2017-05-14 16:59:03 NSDateDemo Local Date: 2017-05-14 16:59:03 +0000 借助 NSDateFormatter 实现NSDate \&lt;-> NSStringNSDate -> NSStringNSDateFormatter *dateformatter = [[NSDateFormatter alloc]init]; [dateformatter setDateFormat:@&quot;YYYY/MM/dd HH:mm:ss&quot;]; NSString *dateStr = [dateformatter stringFromDate:date]; NSLog(@&quot;dateString : %@&quot;,dateStr); date的时间是2017-05-14 09:22:56 而dateStr打印出来却是 2017/05/14 17:22:56 自动帮你加了8小时，是因为dateformatter.timeZone 默认设置成了 Asia/Shanghai (GMT+8) offset 28800 至于蜜汁符号YYYY/MM/dd HH:mm:ss可以参考说明符号文档； NSString -> NSDateNSDate *date1 = [dateformatter dateFromString:dateStr]; NSLog(@&quot;date1 : %@&quot;,date1); NSDate Comparison- (NSDate *)earlierDate:(NSDate *)anotherDate; - (NSDate *)laterDate:(NSDate *)anotherDate; - (NSComparisonResult)compare:(NSDate *)other; - (BOOL)isEqualToDate:(NSDate *)otherDate; NSComparisonResult ： typedef NS_ENUM(NSInteger, NSComparisonResult) {_ NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending }; NSDateComponentsNSDateComponents 和NSCalendar 搭配使用： NSCalendar *calendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; NSDateComponents *components = [calendar components:NSCalendarUnitDay|NSCalendarUnitYear|NSCalendarUnitMonth fromDate:[NSDate date]]; NSLog(@&quot;%@&quot;,components); log结果 Calendar Year: 2017 Month: 5 Leap month: no Day: 14 Tips:计算两个时间相差多少天： NSDateComponents *components = [calendar components:NSCalendarUnitDay fromDate:dateTemp toDate:nowDate options:NSCalendarWrapComponents]; 最后关于NSDate的信息略庞大，后续找个时间来填坑，同时在做这份笔记📒的时候，无意中找到一份比较全面资料A Beginner’s Guide to NSDate in Swift，默默收藏下！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Block 笔记]]></title>
      <url>%2F2017%2F04%2F23%2FBlock-%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Block基础的知识block是C、C++ 、OC 的closure。 block 是在栈上创建的； block 可以复制到堆上； Block 的强大之处：会捕获栈上的变量(或指针)，将其复制为自己私有的const(变量)； (如果在Block中修改Block块外的)栈上的变量和指针，那么这些变量和指针必须用__block关键字申明(否则就会跟上面的情况一样只是捕获他们的瞬时值)。 block的使用block类型的语法结构如下：return_type (^block_name)(arguments) 举个🌰： int (^addBlock)(int a, int b) = ^(int a, int b){ return a + b; } 为常用的block类型创建typedeftypedef return_type(^name)(arguments); 用执行异步任务的“completion handler”来举个🌰： typedef void(^EOCCompletionHandler) (NSData *data, NSError *error); - (void)startWithCompletionHandle:(EOCCompletionHandler)completion; block的命名最好是：类名 + block的功能 + CompletionHandle； 来个🌰： typedef void(^ACAccountStoreSaveCompetionHandle) (BOOL success, NSError *error); 小结：typedef 可以使block使用起来更加简单，如果要refactor代码的时候，只需修改typedef中block的name即可； block的retain cycle当使用代码块和异步分发的时候，要注意避免引用循环。 怎么引起循环引用的呢？举个🌰： self.completionHandler = ^{ NSLog(@&quot;%@&quot;, self); } MyViewController *myController = [[MyViewController alloc] init...]; [self presentViewController:myController animated:YES completion:self.completionHandler]; Retain Cycle ：self通过属性持有block，block持有self，就形成了循环引用。(self -》block -》self) 避免block方法及差异： 在 block 外定义一个 __weak 的引用到 self，并且在 block 里面使用这个弱引用； 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用；方案 1：在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用： __weak typeof(self) weakSelf = self; self.completionHandler = ^{ NSLog(@&quot;%@&quot;, weakSelf); }; MyViewController *myController = [[MyViewController alloc] init...]; [self presentViewController:myController animated:YES completion:self.completionHandler]; 方案 2： 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用。 不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。 __weak typeof(self) weakSelf = self; myObj.myBlock = ^{ __strong typeof(self) strongSelf = weakSelf; if (strongSelf) { [strongSelf doSomething]; // strongSelf != nil // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的) [strongSelf doSomethingElse]; // strongSelf != nil }else { // Probably nothing... return; } }; 小结：方案 1: 当 block 被声明为一个 property 的时候使用。方案 2: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题 对象之间的信息传递的🌰做了个Demo，在两个ViewController之间进行信息的传递，ViewController中设置个label，展示信息，而NextViewController中的textfield中输入要传递的信息string； NextViewController.h typedef void(^PassTextFieldValueBlock)(NSString *string) @interface NextViewController:ViewController @property (nonatomic,copy) PassTextFieldValueBlock passTextFieldValueBlock; @end ViewController.m -(IBACtion)pushNextViewController:(UIButton *)sender{ NextViewController *nextVC = [[NextViewController alloc]init]; __weak typeof(self) weakSelf = self; nextVC.passTextFieldValueBlock = ^(NSString *string){ //call Reset label method; }; [self.navigationController pushViewController:nextVC anmiated:Yes] } 具体的实现过程可以参考BlockDemo]]></content>
    </entry>

    
  
  
</search>
